\section{\protect\isl/ interface}

\subsection{Library}

The \barvinok/ library currently supports just two
functions that interface with the \isl/ library.
In time, this interface will grow and is set to replace
the \PolyLib/ interface.
For more information on the \isl/ data structures, see
the \isl/ user manual.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_set_card(__isl_take isl_set *set);
\end{verbatim}
Compute the number of elements in an \ai[\tt]{isl\_set}.
The resulting \ai[\tt]{isl\_pw\_qpolynomial} has purely parametric cells.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_map_card(__isl_take isl_map *map);
\end{verbatim}
Compute a closed form expression for the number of image elements
associated to any element in the domain of the given \ai[\tt]{isl\_map}.
The union of the cells in the resulting \ai[\tt]{isl\_pw\_qpolynomial}
is equal to the domain of the input \ai[\tt]{isl\_map}.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_sum(
        __isl_take isl_pw_qpolynomial *pwqp);
\end{verbatim}
Compute the sum of the given piecewise quasipolynomial over
all integer points in the domain.  The result is a piecewise
quasipolynomial that only involves the parameters.

\subsection{Calculator}

The \ai[\tt]{iscc} calculator offers an interface to some
of the functionality provided by the \isl/ and \barvinok/
libraries.
The unary operations are shown in \autoref{t:iscc:unary},
while the binary operations are shown in \autoref{t:iscc:binary}.
Here are some examples:
\begin{verbatim}
P := [n, m] -> { [i,j] : 0 <= i <= n and i <= j <= m };
card P;

f := [n,m] -> { [i,j] -> i*j + n*i*i*j : i,j >= 0 and 5i + 27j <= n+m };
sum f;
s := sum f;
s @ [n,m] -> { [] : 0 <= n,m <= 20 };

f := [n] -> { [i] -> 2*n*i - n*n + 3*n - 1/2*i*i - 3/2*i-1 :
                (exists j : 0 <= i < 4*n-1 and 0 <= j < n and
                            2*n-1 <= i+j <= 4*n-2 and i <= 2*n-1 ) };
ub f;
u := ub f;
u @ [n] -> { [] : 0 <= n <= 10 };
\end{verbatim}

\begin{table}
\begin{tabular}{lllp{0.5\textwidth}}
Name & Argument type & Result type & Meaning
\\
\hline
\ai[\tt]{card} & set & pw quasipolynomial &
number of elements in the set
\\
\ai[\tt]{card} & map & pw quasipolynomial &
number of elements in the image of a domain element
\\
\ai[\tt]{dom} & map & set &
domain of map
\\
\ai[\tt]{ran} & map & set &
range of map
\\
\ai[\tt]{lexmin} & set & set &
lexicographically minimal element of a set
\\
\ai[\tt]{lexmin} & map & map &
lexicographically minimal image element
\\
\ai[\tt]{lexmax} & set & set &
lexicographically maximal element of a set
\\
\ai[\tt]{lexmax} & map & map &
lexicographically maximal image element
\\
\ai[\tt]{sample} & set & set &
a sample element of the set
\\
\ai[\tt]{sample} & map & map &
a sample element of the map
\\
\ai[\tt]{sum} & pw qp & pw qp &
sum over all integer points in the domain
\\
\ai[\tt]{ub} & pw qp & pw qp fold &
upper bound on the quasipolynomial over
all integer points in the domain.
This operation is only available if
\ai[\tt]{GiNaC} support was compiled in.
\\
\end{tabular}
\caption{\protect\ai[\tt]{iscc} unary operations}
\label{t:iscc:unary}
\end{table}

\begin{table}
\begin{tabular}{llllp{0.5\textwidth}}
LHS type & Name & RHS type & Result type & Meaning
\\
\hline
set & \ai{$+$} & set & set & union
\\
map & \ai{$+$} & map & map & union
\\
pwqp & \ai{$+$} & pwqp & pwqp & sum
\\
set & \ai{$-$} & set & set & set difference
\\
map & \ai{$-$} & map & map & set difference
\\
pwqp & \ai{$-$} & pwqp & pwqp & difference
\\
set & \ai{$*$} & set & set & intersection
\\
map & \ai{$*$} & map & map & intersection
\\
pwqp & \ai{$*$} & pwqp & pwqp & product
\\
pwqp & \ai{@} & set & pwqp &
evaluate the piecewise quasipolynomial in each element
of the set and return a piecewise quasipolynomial
mapping each of the individual elements to the resulting
constant
\\
pw qp fold & \ai{@} & set & pwqp &
evaluate the piecewise quasipolynomial fold in each element
of the set and return a piecewise quasipolynomial
mapping each of the individual elements to the resulting
constant
\\
\end{tabular}
\caption{\protect\ai[\tt]{iscc} binary operations}
\label{t:iscc:binary}
\end{table}
