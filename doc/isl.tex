\section{\protect\isl/ interface}

\subsection{Library}

The \barvinok/ library currently supports just two
functions that interface with the \isl/ library.
In time, this interface will grow and is set to replace
the \PolyLib/ interface.
For more information on the \isl/ data structures, see
the \isl/ user manual.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_set_card(__isl_take isl_set *set);
\end{verbatim}
Compute the number of elements in an \ai[\tt]{isl\_set}.
The resulting \ai[\tt]{isl\_pw\_qpolynomial} has purely parametric cells.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_map_card(__isl_take isl_map *map);
\end{verbatim}
Compute a closed form expression for the number of image elements
associated to any element in the domain of the given \ai[\tt]{isl\_map}.
The union of the cells in the resulting \ai[\tt]{isl\_pw\_qpolynomial}
is equal to the domain of the input \ai[\tt]{isl\_map}.

\begin{verbatim}
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_sum(
        __isl_take isl_pw_qpolynomial *pwqp);
\end{verbatim}
Compute the sum of the given piecewise quasipolynomial over
all integer points in the domain.  The result is a piecewise
quasipolynomial that only involves the parameters.

\subsection{Calculator}

The \ai[\tt]{iscc} calculator offers an interface to some
of the functionality provided by the \isl/ and \barvinok/
libraries.
The supported operations are shown in \autoref{t:iscc}.
Here are some examples:
\begin{verbatim}
P := [n, m] -> { [i,j] : 0 <= i <= n and i <= j <= m };
card P;

f := [n,m] -> { [i,j] -> i*j + n*i*i*j : i,j >= 0 and 5i + 27j <= n+m };
sum f;
s := sum f;
s @ [n,m] -> { [] : 0 <= n,m <= 20 };

f := [n] -> { [i] -> 2*n*i - n*n + 3*n - 1/2*i*i - 3/2*i-1 :
                (exists j : 0 <= i < 4*n-1 and 0 <= j < n and
                            2*n-1 <= i+j <= 4*n-2 and i <= 2*n-1 ) };
ub f;
u := ub f;
u @ [n] -> { [] : 0 <= n <= 10 };

m := [n] -> { [i,j] -> [i+1,j+1] : 1 <= i,j < n;
              [i,j] -> [i+1,j-1] : 1 <= i < n and 2 <= j <= n };
m^+;
(m^+)[0];
\end{verbatim}

\begin{table}
\begin{tabular}{llp{0.5\textwidth}}
Syntax & Result type & Meaning
\\
\hline
\ai[\tt]{card} {\it set } & pw quasipolynomial &
number of elements in the set
\\
\ai[\tt]{card} {\it map } & pw quasipolynomial &
number of elements in the image of a domain element
\\
\ai[\tt]{dom} {\it map } & set &
domain of map
\\
\ai[\tt]{ran} {\it map } & set &
range of map
\\
\ai[\tt]{lexmin} {\it set } & set &
lexicographically minimal element of a set
\\
\ai[\tt]{lexmin} {\it map } & map &
lexicographically minimal image element
\\
\ai[\tt]{lexmax} {\it set } & set &
lexicographically maximal element of a set
\\
\ai[\tt]{lexmax} {\it map } & map &
lexicographically maximal image element
\\
\ai[\tt]{sample} {\it set } & set &
a sample element of the set
\\
\ai[\tt]{sample} {\it map } & map &
a sample element of the map
\\
\ai[\tt]{sum} {\it pw\_qp } & pw qp &
sum over all integer points in the domain
\\
\ai[\tt]{ub} {\it pwqp } & pw qp fold &
upper bound on the quasipolynomial over
all integer points in the domain.
This operation is only available if
\ai[\tt]{GiNaC} support was compiled in.
\\
{\it set} \ai{$+$} {\it set} & set & union
\\
{\it map} \ai{$+$} {\it map} & map & union
\\
{\it pwqp} \ai{$+$} {\it pwqp} & pwqp & sum
\\
{\it set} \ai{$-$} {\it set} & set & set difference
\\
{\it map} \ai{$-$} {\it map} & map & set difference
\\
{\it pwqp} \ai{$-$} {\it pwqp} & pwqp & difference
\\
{\it set} \ai{$*$} {\it set} & set & intersection
\\
{\it map} \ai{$*$} {\it map} & map & intersection
\\
{\it pwqp} \ai{$*$} {\it pwqp} & pwqp & product
\\
{\it pwqp} \ai{@} {\it set} & pwqp &
evaluate the piecewise quasipolynomial in each element
of the set and return a piecewise quasipolynomial
mapping each of the individual elements to the resulting
constant
\\
{\it pwqpfold} \ai{@} {\it set} & pwqp &
evaluate the piecewise quasipolynomial fold in each element
of the set and return a piecewise quasipolynomial
mapping each of the individual elements to the resulting
constant
\\
{\it map} \ai[\tt]{\^{}+} & list &
compute an overapproximation of the transitive closure
and return a list containing the overapproximation
and a boolean that is true if the overapproximation
is known to be exact
\\
{\it list} [{\it int}] & &
the element at the given position in the list
\\
\end{tabular}
\caption{\protect\ai[\tt]{iscc} operations}
\label{t:iscc}
\end{table}
